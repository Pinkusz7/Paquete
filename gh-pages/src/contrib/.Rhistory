theme(
plot.title   = element_text(size=fs_title, face="bold"),
axis.title.y = element_text(size=fs_axis, face="bold"),
axis.text.x  = element_text(size=fs_axis, angle=45, hjust=1),
axis.text.y  = element_text(size=fs_axis),
axis.line    = element_line(size=axis_size),
axis.ticks   = element_line(size=axis_size),
panel.grid   = element_blank(),
legend.position="none"
)
return(p)
}
} else {
# --- 3.3) Boxplot por cepa ---
if (tipo == "Boxplot") {
df <- datos_agrupados() %>%
filter(Strain == strain) %>%           # cepa seleccionada
order_filter_strain() %>%              # filtro y orden de medios
filter_reps_strain()                   # <<< NUEVO: respeta réplicas
cols <- nlevels(factor(df$Media))
p    <- if (colourMode == "Blanco y Negro") {
ggplot(df, aes(Media, .data[[param_sel]])) +
stat_boxplot(geom="errorbar", width=.2, size=.6, colour="black") +
geom_boxplot(fill="white", colour="black", width=.6, size=.6) +
geom_jitter(colour="black", width=.07, size=2.5)
} else {
ggplot(df, aes(Media, .data[[param_sel]], fill=Media)) +
stat_boxplot(geom="errorbar", width=.2, size=.6) +
geom_boxplot(width=.6, colour="black", size=.6) +
geom_jitter(aes(colour=Media), width=.07, size=2.5) +
scale_fill_manual(values=alpha(safe_hue(cols), .5)) +
scale_colour_manual(values=safe_hue(cols))
}
p <- p + labs(title=paste("Boxplot de", param_sel, "para", strain), y=ylab, x=NULL) +
scale_y_continuous(limits=c(0,ymax), breaks=seq(0,ymax,by=ybreak), expand=c(0,0)) +
theme_minimal() +
theme(
plot.title   = element_text(size=fs_title, face="bold"),
axis.title.y = element_text(size=fs_axis, face="bold"),
axis.text.x  = element_text(size=fs_axis, angle=45, hjust=1),
axis.text.y  = element_text(size=fs_axis),
axis.line    = element_line(size=axis_size),
axis.ticks   = element_line(size=axis_size),
panel.grid   = element_blank(),
legend.position="none"
)
return(p)
}
# --- 3.4) Barras por cepa ---
if (tipo == "Barras") {
df_raw <- datos_agrupados() %>% filter(Strain==strain) %>% order_filter_strain() %>% filter_reps_strain()
resumen <- df_raw %>%
group_by(Media) %>%
summarise(Mean=mean(.data[[param_sel]], na.rm=TRUE),
SD  =sd  (.data[[param_sel]], na.rm=TRUE),
.groups="drop")
cols <- nlevels(resumen$Media)
p    <- if (colourMode == "Blanco y Negro") {
ggplot(resumen, aes(Media, Mean)) +
geom_col(fill="white", colour="black", width=.6) +
geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), width=.2, size=.6, colour="black") +
geom_jitter(data=df_raw, aes(Media, .data[[param_sel]]),
colour="black", width=.07, size=2.5)
} else {
ggplot(resumen, aes(Media, Mean, fill=Media)) +
geom_col(width=.6) +
geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), width=.2, size=.6) +
geom_jitter(data=df_raw, aes(Media, .data[[param_sel]], colour=Media),
width=.07, size=2.5) +
scale_fill_manual(values=alpha(safe_hue(cols), .5)) +
scale_colour_manual(values=safe_hue(cols))
}
p <- p + labs(title=paste("Barras de", param_sel, "para", strain), y=ylab, x=NULL) +
scale_y_continuous(limits=c(0,ymax), breaks=seq(0,ymax,by=ybreak), expand=c(0,0)) +
theme_minimal() +
theme(
plot.title   = element_text(size=fs_title, face="bold"),
axis.title.y = element_text(size=fs_axis, face="bold"),
axis.text.x  = element_text(size=fs_axis, angle=45, hjust=1),
axis.text.y  = element_text(size=fs_axis),
axis.line    = element_line(size=axis_size),
axis.ticks   = element_line(size=axis_size),
panel.grid   = element_blank(),
legend.position="none"
)
return(p)
}
}
# ——— fallback para nunca retornar NULL ———
return( ggplot() + theme_void() )
}
# ---- plot_base: la versión “reactive” que usa la interfaz actual ----
plot_base <- reactive({
# 1) Alcance
scope_sel  <- if (input$scope == "Combinado") "Combinado" else "Por Cepa"
# 2) Cepa (si aplica)
strain_sel <- if (scope_sel == "Por Cepa") input$strain else NULL
# 3) Tipo de gráfico
tipo_sel   <- input$tipo
# 4) Llamada
build_plot(scope  = scope_sel,
strain = strain_sel,
tipo   = tipo_sel)
})
# --- Salidas ---
output$plotInteractivo <- renderPlotly({
p <- plot_base()                     # genera el ggplot
# --- Si p no contiene datos, muestra aviso y no llama a plotly ----
if (length(ggplot_build(p)$data[[1]]$x) == 0) {
showNotification("No hay datos para graficar con la selección actual",
type = "error", duration = 4)
return(NULL)
}
ggplotly(
p,
tooltip      = "all",
width        = input$plot_w,
height       = input$plot_h,
originalData = FALSE
)
})
output$downloadPlot <- downloadHandler(
filename = function() {
base <- if (input$scope == "Combinado") "Combinado" else sanitize(input$strain)
sprintf("%s_%s.png", base, input$tipo)
},
content = function(file) {
ggsave(
file,
plot   = plot_base(),
width  = input$plot_w  / 100,
height = input$plot_h  / 100,
dpi    = 300
)
}
)
output$downloadExcel <- downloadHandler(
filename    = function() "Parametros_por_grupo.xlsx",
contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
content     = function(file) {
# 1) Leer datos combinados y lista de parámetros
datos  <- datos_combinados()
params <- plot_settings()$Parameter
# 2) Crear workbook
wb <- createWorkbook()
for (param in params) {
addWorksheet(wb, sanitize(param))
# 3) Tabla detallada (réplicas técnicas)
det <- datos %>%
filter(!is.na(Strain), !is.na(Media)) %>%
select(Strain, Media, Orden,
BiologicalReplicate, TechnicalReplicate,
all_of(param)) %>%
rename(Valor = all_of(param)) %>%
arrange(Strain, BiologicalReplicate, TechnicalReplicate)
# Definir orden de columnas según 'Orden'
condiciones <- det %>%
select(Media, Orden) %>%
distinct() %>%
arrange(Orden) %>%
pull(Media)
fila <- 1
for (s in unique(det$Strain)) {
writeData(wb , sanitize(param), paste("Strain:", s),
startRow = fila, startCol = 1)
fila <- fila + 1
tab_cepa <- det %>%
filter(Strain == s) %>%
select(BiologicalReplicate, TechnicalReplicate, Media, Valor) %>%
pivot_wider(
id_cols    = c(BiologicalReplicate, TechnicalReplicate),
names_from = Media,
values_from = Valor,
values_fill = NA
) %>%
select(BiologicalReplicate, all_of(condiciones)) %>%
rename(RepBiol = BiologicalReplicate)
writeData(wb , sanitize(param), tab_cepa,
startRow    = fila,
startCol    = 1,
headerStyle = createStyle(textDecoration = "bold"))
fila <- fila + nrow(tab_cepa) + 2
}
# 4) Resumen por réplica biológica (promedios)
writeData(wb, sanitize(param), "Resumen por réplica biológica",
startRow    = fila,
startCol    = 1,
headerStyle = createStyle(fontSize = 12, textDecoration = "bold"))
fila <- fila + 1
resumen <- det %>%
group_by(Strain, BiologicalReplicate, Media) %>%
summarise(Promedio = mean(Valor, na.rm = TRUE), .groups = "drop") %>%
pivot_wider(
id_cols    = c(Strain, BiologicalReplicate),
names_from = Media,
values_from = Promedio,
values_fill = NA
) %>%
arrange(Strain, BiologicalReplicate) %>%
rename(RepBiol = BiologicalReplicate)
writeData(wb, sanitize(param), resumen,
startRow    = fila,
startCol    = 1,
headerStyle = createStyle(textDecoration = "bold"))
}
# 5) Guardar el libro
saveWorkbook(wb, file, overwrite = TRUE)
}
)
# --- Salida: metadata de configuraciones ---
output$downloadMetadata <- downloadHandler(
filename = function() "Metadata_graficos.xlsx",
content = function(file) {
wb <- createWorkbook()
addWorksheet(wb, "PlotSettings")
writeData(wb, "PlotSettings", plot_settings())
saveWorkbook(wb, file, overwrite = TRUE)
}
)
# --- Salida: ZIP con todo (Excel grupal + metadata + PNGs + tests) ---
output$downloadAll <- downloadHandler(
filename    = function() "Resultados_completos.zip",
contentType = "application/zip",
content     = function(file) {
# — 1) capturar inputs con isolate() y valores por defecto —
scope_sel       <- isolate(input$scope)       %||% "Por Cepa"
sigTest_sel     <- isolate(input$sigTest)     %||% "ANOVA"
postHoc_sel     <- isolate(input$postHoc)     %||% "Tukey"
compMode_sel    <- isolate(input$compMode)    %||% "all"
controlGroup_sel<- isolate(input$controlGroup)%||% ""
group1_sel      <- isolate(input$group1)      %||% ""
group2_sel      <- isolate(input$group2)      %||% ""
# — 2) carpeta temporal y parámetros —
outdir <- file.path(tempdir(), paste0("shiny_outputs_", Sys.getpid()))
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)
params <- plot_settings()$Parameter
datos  <- datos_combinados()
# — 3) Excel principal —
wb1 <- createWorkbook()
for (param in params) {
addWorksheet(wb1, safe_sheet(param))
# … llenar workbook …
}
saveWorkbook(wb1, file.path(outdir, "Parametros_por_grupo.xlsx"), overwrite = TRUE)
# — 4) Tests estadísticos —
wb_tests <- createWorkbook()
has_tests <- FALSE
for (param in params) {
sheet <- safe_sheet(param)
addWorksheet(wb_tests, sheet)
# reconstruir df_param con las variables aisladas
if (scope_sel == "Por Cepa") {
df_param <- datos_agrupados() %>%
filter(Strain == input$strain) %>%  # Strain siempre existe si scope_sel lo indica
order_filter_strain() %>%
filter_reps_strain() %>%
transmute(Label = Media, Valor = .data[[param]])
} else {
df_param <- datos_agrupados() %>%
order_filter_group() %>%
transmute(Label, Valor = .data[[param]])
}
# saltar si no hay suficientes datos
if (nrow(df_param) < 3 || n_distinct(df_param$Label) < 2) {
removeWorksheet(wb_tests, sheet)
next
}
# normalidad
norm_tbl <- df_param %>%
group_by(Label) %>%
summarise(
Shapiro.stat = shapiro.test(Valor)$statistic,
Shapiro.p    = shapiro.test(Valor)$p.value,
Normal       = if_else(Shapiro.p > 0.05, "Sí", "No"),
.groups      = "drop"
)
writeData(wb_tests, sheet, "Normalidad", startRow=1, startCol=1,
headerStyle = createStyle(textDecoration = "bold"))
writeData(wb_tests, sheet, norm_tbl,      startRow=2, startCol=1,
headerStyle = createStyle(textDecoration = "bold"))
# significancia
sig_tbl <- switch(
sigTest_sel,
"ANOVA" = {
global <- rstatix::anova_test(df_param, Valor ~ Label) |> as_tibble() |>
mutate(.section="ANOVA_global", .before=1)
if (postHoc_sel == "Tukey") {
post <- rstatix::tukey_hsd(df_param, Valor ~ Label) |> as_tibble() |>
mutate(.section="Tukey_posthoc", .before=1)
bind_rows(global, post)
} else global
},
"Kruskal–Wallis" = {
global <- rstatix::kruskal_test(df_param, Valor ~ Label) |> as_tibble() |>
mutate(.section="KW_global", .before=1)
if (postHoc_sel == "Dunn (Bonf.)") {
post <- rstatix::dunn_test(df_param, Valor ~ Label, p.adjust.method="bonferroni") |> as_tibble() |>
mutate(.section="Dunn_posthoc", .before=1)
bind_rows(global, post)
} else global
},
"ttest" = {
tbl <- if (compMode_sel=="all")
rstatix::pairwise_t_test(df_param, Valor ~ Label, p.adjust.method="holm")
else if (compMode_sel=="control")
rstatix::t_test(df_param, Valor ~ Label, ref.group=controlGroup_sel)
else
rstatix::t_test(df_param %>% filter(Label %in% c(group1_sel,group2_sel)),
Valor ~ Label)
as_tibble(tbl) |> mutate(.section="t-test", .before=1)
},
"wilcox" = {
tbl <- if (compMode_sel=="all")
rstatix::pairwise_wilcox_test(df_param, Valor ~ Label, p.adjust.method="holm")
else if (compMode_sel=="control")
rstatix::wilcox_test(df_param, Valor ~ Label, ref.group=controlGroup_sel)
else
rstatix::wilcox_test(df_param %>% filter(Label %in% c(group1_sel,group2_sel)),
Valor ~ Label)
as_tibble(tbl) |> mutate(.section="Wilcoxon", .before=1)
}
)
start <- nrow(norm_tbl) + 4
writeData(wb_tests, sheet, paste("Test usado:", sigTest_sel),
startRow=start-1, startCol=1,
headerStyle = createStyle(textDecoration="bold"))
writeData(wb_tests, sheet, "Significancia",
startRow=start, startCol=1,
headerStyle = createStyle(textDecoration="bold"))
writeData(wb_tests, sheet, sig_tbl,
startRow=start+1, startCol=1,
headerStyle = createStyle(textDecoration="bold"))
has_tests <- TRUE
}
# guardar Tests_estadisticos sólo si hay
tests_path <- file.path(outdir, "Tests_estadisticos.xlsx")
if (has_tests) {
saveWorkbook(wb_tests, tests_path, overwrite = TRUE)
}
# 3) Metadata por tipo de gráfico
for (tipo in c("Boxplot", "Barras")) {
wb_meta <- createWorkbook()
addWorksheet(wb_meta, "Metadata")
writeData(wb_meta, "Metadata", tibble::tibble(
Parámetro = c("scope","tipo","param","colorMode","plot_w","plot_h","ymax","ybreak"),
Valor     = c(
input$scope, tipo, input$param, input$colorMode,
input$plot_w, input$plot_h,
ylims[[input$param]]$ymax,
ylims[[input$param]]$ybreak
)
))
saveWorkbook(wb_meta,
file.path(outdir, paste0("metadata_", tipo, ".xlsx")),
overwrite = TRUE)
}
# 4) PNGs para cepas y siempre también los combinados ----
# capturar selección actual de gráficas
selGraphs <- isolate(input$selectedGraphs) %||% character(0)
# construir siempre las dos gráficas combinadas
comboGraphs <- paste0("Combinado_", c("Boxplot", "Barras"))
selGraphs   <- unique(c(selGraphs, comboGraphs))
for (lbl in selGraphs) {
# parts[1] = "Combinado" o nombre de la cepa; parts[2] = tipo de gráfico
parts <- strsplit(lbl, "_")[[1]]
p     <- if (parts[1] == "Combinado") {
build_plot("Combinado", NULL, parts[2])
} else {
build_plot("Por Cepa", parts[1], parts[2])
}
# nombre de archivo seguro
fname <- paste0(gsub("[^A-Za-z0-9_\\-]", "_", lbl), ".png")
ggsave(
filename = file.path(outdir, fname),
plot     = p,
width    = input$plot_w  / 100,
height   = input$plot_h  / 100,
dpi      = 300
)
}
# 5) Compactar todo en ZIP
files2zip <- list.files(outdir, full.names = TRUE)
if (!has_tests && file.exists(tests_path)) {
files2zip <- setdiff(files2zip, tests_path)
}
validate(need(length(files2zip) > 0, "No hay archivos para comprimir."))
tmp_zip <- tempfile(fileext = ".zip")
zip::zipr(tmp_zip, files2zip)
file.copy(tmp_zip, file, overwrite = TRUE)
unlink(outdir, recursive = TRUE)
unlink(tmp_zip)
}  # cierra content = function(file)
)    # cierra downloadHandler(
}
# Lanzar app
shinyApp(ui, server)
runApp('~/SZEN.R')
runApp('~/SZEN.R')
runApp('~/SZEN.R')
###############################################################################
#  PROBADOR RÁPIDO: comprueba que el repositorio mini-CRAN funciona
#  (solo hace la descarga, instala en una carpeta temporal y muestra la versión)
###############################################################################
# 1) URL pública de tu GitHub Pages
repo_url <- "https://pinkusz7.github.io/bioszenSZ/"
# 2) apuntamos un repositorio temporal SOLO para esta sesión
op <- options(repos = c(MyBioRepo = repo_url, getOption("repos")))
# 3) ¿qué versiones ve R en ese repositorio?
avail <- utils::available.packages(
contriburl = utils::contrib.url(repo_url, "source"))
print(avail["BIOSZEN", c("Package", "Version")])
# 4) instálalo en una librería temporal (no toca tu librería habitual)
tmp_lib <- tempfile("lib")
dir.create(tmp_lib)
install.packages("BIOSZEN",
lib  = tmp_lib,
type = "source",
dependencies = FALSE)
# 5) cárgalo desde la librería temporal y muestra versión
library(BIOSZEN, lib.loc = tmp_lib)
cat("BIOSZEN instalado OK — versión:",
as.character(utils::packageVersion("BIOSZEN")), "\n")
# 6) opcional: lanzar la app
# BIOSZEN::run_app()
# 7) restaurar opciones originales
options(op)
library(BIOSZEN)
BIOSZEN::run_app()
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
if (interactive()) {
ans <- tolower(substr(readline(
sprintf("Instalar/actualizar %s a %s (≈1-2 min)? [S/n]: ",
pkg, latest)), 1, 1))
ok <- ans %in% c("", "s", "y")
}
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ2.R")
runApp('D:/GISTS/Comandos Repositorio/ComandosSZ/App/inst/app/BIOSZEN.R')
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
## --- Bloque autosuficiente: instala (solo si falta) y lanza BIOSZEN ----
pkg <- "BIOSZEN"                                    # nombre del paquete
zip_path <- "D:/GISTS/BIOSZEN_1.0.0.tar.gz"          # ← AJUSTA AQUÍ LA RUTA
if (!requireNamespace(pkg, quietly = TRUE)) {
message("No se encontró ‘", pkg, "’. Instalando desde:\n  ", zip_path)
install.packages(zip_path,
repos = NULL,
type  = "source")               # o "win.binary" si es .zip
}
library(BIOSZEN)
BIOSZEN::run_app()          # abre la aplicación en el navegador
app_dir <- system.file(package = "BIOSZEN")
list.files(app_dir, recursive = TRUE, pattern = "app\\.R$", full.names = TRUE)
shiny::runApp(dirname(app_r_found), display.mode = "showcase")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
remove.packages("BIOSZEN")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
install.packages("BIOSZEN_1.0.0.tar.gz", repos = NULL, type = "source")
library(BIOSZEN)
BIOSZEN::run_app()
install.packages("BIOSZEN_1.0.0.tar.gz", repos = NULL, type = "source")
library(BIOSZEN)
BIOSZEN::run_app()
## --- Bloque autosuficiente: instala (solo si falta) y lanza BIOSZEN ----
pkg <- "BIOSZEN"                                    # nombre del paquete
zip_path <- "D:/GISTS/BIOSZEN_1.0.0.tar.gz"         # ← AJUSTA AQUÍ LA RUTA
## --- Bloque autosuficiente: instala (solo si falta) y lanza BIOSZEN ----
## --- Bloque autosuficiente: instala (solo si falta) y lanza BIOSZEN ----
pkg <- "BIOSZEN"                                    # nombre del paquete
zip_path <- "D:/GISTS/BIOSZEN_1.0.0.tar.gz"         # ← AJUSTA AQUÍ LA RUTA
if (!requireNamespace(pkg, quietly = TRUE)) {
message("No se encontró ‘", pkg, "’. Instalando desde:\n  ", zip_path)
install.packages(zip_path,
repos = NULL,
type  = "source")               # o "win.binary" si es .zip
}
library(BIOSZEN)
BIOSZEN::run_app()          # abre la aplicación en el navegador
BIOSZEN::run_app()          # abre la aplicación en el navegador
library(BIOSZEN)
app_dir <- system.file("app", package = "BIOSZEN")
app_dir                         # → debería imprimir una ruta tipo “C:/…/BIOSZEN/app”
list.files(app_dir, recursive = TRUE)
shiny::runApp(app_dir, display.mode = "showcase")
BIOSZEN
# 1. Lee las últimas líneas de app.R
tail(readLines(file.path(app_dir, "app.R")), 15)
library(BIOSZEN)
BIOSZEN::run_app()   # debería abrir la aplicación sin errores
library(BIOSZEN, launch = TRUE)
BIOSZEN
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
remove.packages("BIOSZEN")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
source("C:/Users/benja/OneDrive/Escritorio/SZ.R")
r<br>setwd("D:/app/Paquete/src/contrib")      # ajusta tu ruta<br>tools::write_PACKAGES(".", type = "source")  # genera PACKAGES, PACKAGES.gz y .rds<br>
setwd("D:/app/Paquete/src/contrib")   # carpeta donde está el .tar.gz
tools::write_PACKAGES(".", type = "source")  # genera PACKAGES, PACKAGES.gz y PACKAGES.rds
